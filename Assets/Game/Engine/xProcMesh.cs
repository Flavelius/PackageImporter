//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using Engine;
using SBAI;
using SBAIScripts;
using SBBase;
using SBGame;
using SBGamePlay;
using SBMiniGames;
using System;
using System.Collections;
using System.Collections.Generic;
using Framework.Attributes;

namespace Engine
{
    
    
    [System.Serializable] public class xProcMesh : Actor
    {
        
        [FieldConst()]
        public List<ProcMeshVertex> Vertices = new List<ProcMeshVertex>();
        
        [FieldConst()]
        public List<int> SectionOffsets = new List<int>();
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public float Dampening;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public Range DampeningRange;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public Range MovementClamp;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public Range ForceClamp;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public float ForceAttenuation;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public float Tension;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public float RestTension;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public bool CheckCollision;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public float Noise;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public Range NoiseForce;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public Range NoiseTimer;
        
        [System.NonSerialized, UnityEngine.HideInInspector]
        [FieldTransient()]
        public float NoiseCounter;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public byte ProcType;
        
        [Sirenix.OdinInspector.FoldoutGroup("Force")]
        public bool bForceAffected;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public bool bRigidEdges;
        
        [FieldConst()]
        [System.NonSerialized, UnityEngine.HideInInspector]
        [FieldTransient()]
        public int pProcData;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        [TypeProxyDefinition(TypeName="Effects")]
        public System.Type HitEffect;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        [TypeProxyDefinition(TypeName="Effects")]
        public System.Type BigHitEffect;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public float BigMomentumThreshold;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public float BigTouchThreshold;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public float ShootStrength;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public float TouchStrength;
        
        [Sirenix.OdinInspector.FoldoutGroup("xProcMesh")]
        public float InfluenceRadius;
        
        public xProcMesh()
        {
        }
        
        [System.Serializable] public struct ProcMeshVertex
        {
            
            public Vector Position;
            
            public Vector Normal;
            
            public Color Color;
            
            public float U;
            
            public float V;
        }
        
        public enum EProcMeshType
        {
            
            MT_Water ,
            
            MT_Deform,
        }
    }
}
/*
simulated function Touch(Actor Other) {
local Vector touchLocation;
local Vector EffectNormal;
local Vector EffectLocation;
local float touchValue;
Super.Touch(Other);                                                         
if (Other == None || !Other.bDisturbFluidSurface) {                         
return;                                                                   
}
touchLocation = Other.Location;                                             
touchValue = VSize(Velocity);                                               
ProcPling(touchLocation,TouchStrength,Other.CollisionRadius,EffectLocation,EffectNormal);
if (touchValue > BigTouchThreshold && BigHitEffect != None) {               
Spawn(BigHitEffect,self,,EffectLocation,rotator(EffectNormal));           
} else {                                                                    
if (HitEffect != None) {                                                  
Spawn(HitEffect,self,,EffectLocation,rotator(EffectNormal));            
}
}
}
simulated function TakeDamage(int Damage,Pawn instigatedBy,Vector HitLocation,Vector Momentum,class<DamageType> DamageType) {
local Vector EffectNormal;
local Vector EffectLocation;
ProcPling(HitLocation,ShootStrength,0.00000000,EffectLocation,EffectNormal);
if (VSize(Momentum) > BigMomentumThreshold
&& BigHitEffect != None) { 
Spawn(BigHitEffect,self,,EffectLocation,rotator(EffectNormal));           
} else {                                                                    
if (HitEffect != None) {                                                  
Spawn(HitEffect,self,,EffectLocation,rotator(EffectNormal));            
}
}
}
final native function ProcPling(Vector Position,float Strength,float Radius,out Vector EffectLocation,out Vector EffectNormal);
*/
