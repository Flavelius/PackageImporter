//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using Engine;
using SBAI;
using SBAIScripts;
using SBBase;
using SBGame;
using SBGamePlay;
using SBMiniGames;
using System;
using System.Collections;
using System.Collections.Generic;
using Framework.Attributes;

namespace Engine
{
    
    
    public class Fragment : Effects
    {
        
        [FieldCategory(Category="Fragment")]
        [IgnoreFieldExtraction()]
        [ArraySizeForExtraction(Size=11)]
        public Mesh[] Fragments = new Mesh[0];
        
        public int numFragmentTypes;
        
        public bool bFirstHit;
        
        [FieldCategory(Category="Fragment")]
        [IgnoreFieldExtraction()]
        public Sound ImpactSound;
        
        [FieldCategory(Category="Fragment")]
        [IgnoreFieldExtraction()]
        public Sound AltImpactSound;
        
        [FieldCategory(Category="Fragment")]
        public float SplashTime;
        
        public Fragment()
        {
        }
    }
}
/*
final simulated function RandSpin(float spinRate) {
DesiredRotation = RotRand();                                                
RotationRate.Yaw = spinRate * 2 * FRand() - spinRate;                       
RotationRate.Pitch = spinRate * 2 * FRand() - spinRate;                     
RotationRate.Roll = spinRate * 2 * FRand() - spinRate;                      
}
simulated function HitWall(Vector HitNormal,Actor HitWall) {
local float speed;
Velocity = 0.50000000 * (Velocity Dot HitNormal * HitNormal * -2.00000000 + Velocity);
speed = VSize(Velocity);                                                    
if (bFirstHit && speed < 400) {                                             
bFirstHit = False;                                                        
bRotateToDesired = True;                                                  
bFixedRotationDir = False;                                                
DesiredRotation.Pitch = 0;                                                
DesiredRotation.Yaw = FRand() * 65536;                                    
DesiredRotation.Roll = 0;                                                 
}
RotationRate.Yaw = RotationRate.Yaw * 0.75000000;                           
RotationRate.Roll = RotationRate.Roll * 0.75000000;                         
RotationRate.Pitch = RotationRate.Pitch * 0.75000000;                       
if (speed < 60 && HitNormal.Z > 0.69999999) {                               
SetPhysics(0);                                                            
bBounce = False;                                                          
GotoState('Dying');                                                       
} else {                                                                    
if (speed > 80) {                                                         
if (FRand() < 0.50000000) {                                             
PlaySound(ImpactSound,0,,,300.00000000,0.85000002 + FRand() * 0.30000001,True);
} else {                                                                
PlaySound(AltImpactSound,0,,,300.00000000,0.85000002 + FRand() * 0.30000001,True);
}
}
}
}
simulated function CalcVelocity(Vector Momentum) {
local float ExplosionSize;
ExplosionSize = 0.01100000 * VSize(Momentum);                               
Velocity = 0.00330000 * Momentum + 0.69999999 * VRand() * (ExplosionSize + FRand() * 100.00000000 + 100.00000000);
Velocity.Z += 0.50000000 * ExplosionSize;                                   
}
function bool CanSplash() {
if (Level.TimeSeconds - SplashTime > 0.25000000
&& Physics == 2
&& Abs(Velocity.Z) > 100) {
SplashTime = Level.TimeSeconds;                                           
return True;                                                              
}
return False;                                                               
}
state Dying {
simulated function BeginState() {
SetTimer(1.00000000 + FRand(),True);                                    
SetCollision(True,False);                                               
}
simulated function Timer() {
if (!PlayerCanSeeMe()) {                                                
Destroy();                                                            
}
}
function TakeDamage(int Dam,Pawn instigatedBy,Vector HitLocation,Vector Momentum,class<DamageType> DamageType) {
Destroy();                                                              
}
}
auto state Flying {
simulated function BeginState() {
RandSpin(125000.00000000);                                              
if (Abs(RotationRate.Pitch) < 10000) {                                  
RotationRate.Pitch = 10000;                                           
}
if (Abs(RotationRate.Roll) < 10000) {                                   
RotationRate.Roll = 10000;                                            
}
LinkMesh(Fragments[FRand() * numFragmentTypes]);                        
if (Level.NetMode == 0) {                                               
LifeSpan = 20.00000000 + 40 * FRand();                                
}
SetTimer(5.00000000,True);                                              
}
singular simulated function PhysicsVolumeChange(PhysicsVolume NewVolume) {
if (NewVolume.bWaterVolume) {                                           
Velocity = 0.20000000 * Velocity;                                     
if (bFirstHit) {                                                      
bFirstHit = False;                                                  
bRotateToDesired = True;                                            
bFixedRotationDir = False;                                          
DesiredRotation.Pitch = 0;                                          
DesiredRotation.Yaw = FRand() * 65536;                              
DesiredRotation.Roll = 0;                                           
}
RotationRate = 0.20000000 * RotationRate;                             
GotoState('Dying');                                                   
}
}
simulated function Timer() {
GotoState('Dying');                                                     
}
}
*/
