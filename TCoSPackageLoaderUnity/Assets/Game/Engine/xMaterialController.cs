//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using Engine;
using SBAI;
using SBAIScripts;
using SBBase;
using SBGame;
using SBGamePlay;
using SBMiniGames;
using System;
using System.Collections;
using System.Collections.Generic;
using Framework.Attributes;

namespace Engine
{
    
    
    public class xMaterialController : Actor
    {
        
        [FieldCategory(Category="xMaterialController")]
        [IgnoreFieldExtraction()]
        public Material Target;
        
        [FieldCategory(Category="xMaterialController")]
        [IgnoreFieldExtraction()]
        public Material SwapMaterialA;
        
        [FieldCategory(Category="xMaterialController")]
        [IgnoreFieldExtraction()]
        public Material SwapMaterialB;
        
        [FieldCategory(Category="xMaterialController")]
        public byte MatTriggerAction;
        
        [FieldCategory(Category="xMaterialController")]
        public byte MatTickFunc;
        
        [FieldCategory(Category="xMaterialController")]
        public float MatTickValue;
        
        [IgnoreFieldExtraction()]
        [FieldTransient()]
        public float tickAccum;
        
        [IgnoreFieldExtraction()]
        [FieldTransient()]
        public float tickPtA;
        
        [IgnoreFieldExtraction()]
        [FieldTransient()]
        public float tickPtB;
        
        [IgnoreFieldExtraction()]
        [FieldTransient()]
        public bool triggerOn;
        
        public xMaterialController()
        {
        }
        
        public enum EMatTickFunc
        {
            
            MTF_PulseConstantColor ,
            
            MTF_FadeConstantColor ,
            
            MTF_NoAction,
        }
        
        public enum EMatAction
        {
            
            MTA_SwapShaderDiffuse ,
            
            MTA_SwapShaderSelfIllum ,
            
            MTA_SwapShaderSpecular ,
            
            MTA_SwapCombinerMat1 ,
            
            MTA_SwapCombinerMat2 ,
            
            MTA_NoAction,
        }
    }
}
/*
simulated event Trigger(Actor Other,Pawn EventInstigator) {
local Material tmp;
if (MatTriggerAction == 5) {                                                
return;                                                                   
}
tmp = SwapMaterialA;                                                        
SwapMaterialA = SwapMaterialB;                                              
SwapMaterialB = tmp;                                                        
triggerOn = !triggerOn;                                                     
if (Target.IsA('Shader')) {                                                 
ShaderAction(Shader(Target));                                             
} else {                                                                    
if (Target.IsA('Combiner')) {                                             
CombinerAction(Combiner(Target));                                       
} else {                                                                  
Log("Incompatible material in xMaterialTrigger",'Warning');             
}
}
if (Target.IsA('Shader')
&& Shader(Target).SpecularityMask.IsA('ConstantColor')) {
if (triggerOn) {                                                          
tickPtA = ConstantColor(Shader(Target).SpecularityMask).Color.A;        
tickPtB = 255.00000000;                                                 
} else {                                                                  
tickPtA = ConstantColor(Shader(Target).SpecularityMask).Color.A;        
tickPtB = 0.00000000;                                                   
}
tickAccum = 0.00000000;                                                   
switch (MatTickFunc) {                                                    
case 1 :                                                                
case 0 :                                                                
Enable('Tick');                                                       
break;                                                                
default:                                                                
}
}
}
simulated function CombinerAction(Combiner cb) {
}
simulated function ShaderAction(Shader sh) {
switch (MatTriggerAction) {                                                 
case 2 :                                                                  
sh.Specular = SwapMaterialA;                                            
break;                                                                  
default:                                                                  
}
}
simulated function Tick(float t) {
Super.Tick(t);                                                              
if (MatTickFunc == 2) {                                                     
return;                                                                   
}
if (Target.IsA('Shader')
&& Shader(Target).SpecularityMask.IsA('ConstantColor')) {
TickConstantColor(ConstantColor(Shader(Target).SpecularityMask),t);       
} else {                                                                    
if (Target.IsA('ConstantColor')) {                                        
TickConstantColor(ConstantColor(Target),t);                             
}
}
}
simulated function TickConstantColor(ConstantColor cc,float t) {
local float F;
local float Alpha;
tickAccum += t;                                                             
if (tickAccum >= 1.00000000) {                                              
tickAccum = 1.00000000;                                                   
}
if (MatTickFunc == 1) {                                                     
if (tickAccum >= 1.00000000) {                                            
Disable('Tick');                                                        
}
Alpha = tickPtA + tickAccum * (tickPtB - tickPtA);                        
} else {                                                                    
if (MatTickFunc == 0) {                                                   
Alpha = tickPtA + tickAccum * (tickPtB - tickPtA);                      
F = Level.TimeSeconds * MatTickValue;                                   
F = F - F;                                                              
Alpha = Pulse(F) * Alpha;                                               
}
}
cc.Color.A = Alpha;                                                         
}
simulated function PostBeginPlay() {
tickPtA = 255.00000000;                                                     
tickPtB = 255.00000000;                                                     
}
simulated function float Pulse(float X) {
if (X < 0.50000000) {                                                       
return 2.00000000 * X * X * (3.00000000 - 2.00000000 * X);                
} else {                                                                    
return 2.00000000 * (1.00000000 - X * X * (3.00000000 - 2.00000000 * X)); 
}
}
*/
