//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using Engine;
using SBAI;
using SBAIScripts;
using SBBase;
using SBGame;
using SBGamePlay;
using SBMiniGames;
using System;
using System.Collections;
using System.Collections.Generic;
using Framework.Attributes;

namespace Engine
{
    
    
    public class NavigationPoint : Actor
    {
        
        [IgnoreFieldExtraction()]
        [FieldTransient()]
        public bool bEndPoint;
        
        [IgnoreFieldExtraction()]
        [FieldTransient()]
        public bool bTransientEndPoint;
        
        [IgnoreFieldExtraction()]
        [FieldTransient()]
        public bool bHideEditorPaths;
        
        [IgnoreFieldExtraction()]
        [FieldTransient()]
        public bool bCanReach;
        
        public bool taken;
        
        [FieldCategory(Category="NavigationPoint")]
        public bool bBlocked;
        
        [FieldCategory(Category="NavigationPoint")]
        public bool bPropagatesSound;
        
        [FieldCategory(Category="NavigationPoint")]
        public bool bOneWayPath;
        
        [FieldCategory(Category="NavigationPoint")]
        public bool bNeverUseStrafing;
        
        [FieldCategory(Category="NavigationPoint")]
        public bool bAlwaysUseStrafing;
        
        [FieldConst()]
        public bool bForceNoStrafing;
        
        [FieldConst()]
        public bool bAutoBuilt;
        
        public bool bSpecialMove;
        
        public bool bNoAutoConnect;
        
        [FieldConst()]
        public bool bNotBased;
        
        [FieldConst()]
        public bool bPathsChanged;
        
        public bool bDestinationOnly;
        
        public bool bSourceOnly;
        
        public bool bSpecialForced;
        
        public bool bMustBeReachable;
        
        public bool bBlockable;
        
        public bool bFlyingPreferred;
        
        public bool bMayCausePain;
        
        public bool bReceivePlayerToucherDiedNotify;
        
        public bool bAlreadyVisited;
        
        [FieldCategory(Category="NavigationPoint")]
        public bool bVehicleDestination;
        
        [FieldCategory(Category="NavigationPoint")]
        public bool bMakeSourceOnly;
        
        [FieldCategory(Category="NavigationPoint")]
        public bool bNoSuperSize;
        
        public bool bForcedOnly;
        
        [FieldConst()]
        public List<ReachSpec> PathList = new List<ReachSpec>();
        
        [FieldCategory(Category="NavigationPoint")]
        [ArraySizeForExtraction(Size=4)]
        public NameProperty[] ProscribedPaths = new NameProperty[0];
        
        [FieldCategory(Category="NavigationPoint")]
        [ArraySizeForExtraction(Size=4)]
        public NameProperty[] ForcedPaths = new NameProperty[0];
        
        public int visitedWeight;
        
        [FieldConst()]
        public int bestPathWeight;
        
        [FieldConst()]
        public NavigationPoint nextNavigationPoint;
        
        [FieldConst()]
        public NavigationPoint nextOrdered;
        
        [FieldConst()]
        public NavigationPoint prevOrdered;
        
        [FieldConst()]
        public NavigationPoint previousPath;
        
        public int cost;
        
        [FieldCategory(Category="NavigationPoint")]
        public int ExtraCost;
        
        [IgnoreFieldExtraction()]
        [FieldTransient()]
        public int TransientCost;
        
        [IgnoreFieldExtraction()]
        [FieldTransient()]
        public int FearCost;
        
        [FieldConst()]
        public float LastDetourWeight;
        
        [ArraySizeForExtraction(Size=2)]
        public byte[] BaseVisible = new byte[0];
        
        [ArraySizeForExtraction(Size=2)]
        public float[] BaseDist = new float[0];
        
        public Vector MaxPathSize;
        
        public NavigationPoint()
        {
        }
    }
}
/*
function PlayerToucherDied(Pawn P);
function MoverClosed();
function MoverOpened();
function bool ProceedWithMove(Pawn Other) {
return True;                                                                
}
event bool SuggestMovePreparation(Pawn Other) {
return False;                                                               
}
event float DetourWeight(Pawn Other,float PathWeight);
event bool Accept(Actor Incoming,Actor Source) {
taken = Incoming.SetLocation(Location);                                     
if (taken) {                                                                
Incoming.Velocity = vect(0.000000, 0.000000, 0.000000);                   
Incoming.SetRotation(Rotation);                                           
}
Incoming.PlayTeleportEffect(True,False);                                    
TriggerEvent(Event,self,Pawn(Incoming));                                    
return taken;                                                               
}
event int SpecialCost(Pawn Seeker,ReachSpec Path);
function SetBaseVisibility(int BaseNum) {
local NavigationPoint N;
BaseVisible[BaseNum] = 1;                                                   
N = Level.NavigationPointList;                                              
while (N != None) {                                                         
if (N.BaseVisible[BaseNum] == 0
&& FastTrace(N.Location + (88 - 2 * N.CollisionHeight) * vect(0.000000, 0.000000, 1.000000),Location + (88 - 2 * N.CollisionHeight) * vect(0.000000, 0.000000, 1.000000))) {
N.BaseVisible[BaseNum] = 1;                                             
}
N = N.nextNavigationPoint;                                                
}
}
final native function SetBaseDistance(int BaseNum);
function PostBeginPlay() {
local int i;
ExtraCost = Max(ExtraCost,0);                                               
i = 0;                                                                      
while (i < PathList.Length) {                                               
MaxPathSize.X = FMax(MaxPathSize.X,PathList[i].CollisionRadius);          
MaxPathSize.Z = FMax(MaxPathSize.Z,PathList[i].CollisionHeight);          
i++;                                                                      
}
MaxPathSize.Y = MaxPathSize.X;                                              
Super.PostBeginPlay();                                                      
}
*/
